#include "uart.h"

#define GPIOAEN				(1U << 0)
#define UART2EN				(1U << 17)
#define UART2_BAUDRATE		115200
#define SYS_FREQ 			16000000
#define APB1_CLK 			SYS_FREQ
#define CR1_TE 				(1U << 3)
#define CR1_RE 				(1U << 2)
#define CR1_UE				(1U << 13)
#define SR_TXE				(1U << 7)

void uart_init(void)
{
	/* Enable clock access to GPIOA */
	RCC->AHB1ENR |= GPIOAEN;

	/* Set the mode of PA2 and PA3 to alternate function mode */
	GPIOA->MODER &= ~(1U << 4);
	GPIOA->MODER |= (1U << 5);
	GPIOA->MODER &= ~(1U << 6);
	GPIOA->MODER |= (1U << 7);

	/* Set alternate function type to AF7(UART2_TX) */
	GPIOA->AFR[0] |= (1U << 8);
	GPIOA->AFR[0] |= (1U << 9);
	GPIOA->AFR[0] |= (1U << 10);
	GPIOA->AFR[0] &= ~(1U << 11);

	/* Set alternate function type to AF7(UART2_RX) */
	GPIOA->AFR[0] |= (1U << 12);
	GPIOA->AFR[0] |= (1U << 13);
	GPIOA->AFR[0] |= (1U << 14);
	GPIOA->AFR[0] &= ~(1U << 15);

	/* Enable clock access to UART2 */
	RCC->APB1ENR |= UART2EN;

	/* Configure UART baudrate */
	uint32_t usartdiv_mult16 = APB1_CLK / UART2_BAUDRATE;
	uint32_t mantissa = usartdiv_mult16 / 16U;
	uint32_t fractional = usartdiv_mult16 % 16U;
	USART2->BRR = (mantissa << 4) | (fractional & 0x0F);

	/* Configure transfer direction */
	USART2->CR1 = CR1_TE | CR1_RE;

	/* Enable UART Module */
	USART2->CR1 |= CR1_UE;
}

void uart_write(uint8_t ch)
{
	 /* Make sure transmit data register is empty */
	while (!(USART2->SR & USART_SR_TXE));

	 /* Write to transmit data register */
	USART2->DR = ch;
}

uint8_t uart_read(void)
{
    /* Wait until data is received */
	while (!(USART2->SR & USART_SR_RXNE));

    /* Read from Receive Data Register */
	return (uint8_t)(USART2->DR & 0xFF);
}

void uart_print(const char *str)
{
    while (*str) uart_write((uint8_t)*str++);
}

